# 基礎知識
## 2の補数
ビット反転させて1を足す

# メモリ管理
## 読み込み
### デマンドページング
ページが参照され，ページフォルトがおきたとき，ページを主記憶に読み込む
### プリページング
ページが参照される前にページを主記憶に読み込む(うまく行けば速い)
## 書き込み
### FIFO
読み込んだ順番が早い順に書き換え
### LRU
最後に読み込んだ時間が一番古いものと置き換え
#### 問題
一回の参照ごとに"すべての"ページの時間の置き換えが必要
### NRU
参照ビットと更新ビットを用意して更新優先度をつける
- 参照ビット:参照されると1,何らかの"置き"換えがあると0に戻る
- 更新ビット:書き込みで1,ベージアウトされると0
  
- クラス0:参照ビット0更新ビット0
- クラス1:参照ビット0更新ビット1
- クラス2:参照ビット1更新ビット0
- クラス3:参照ビット1更新ビット1
### NFU
アクセス頻度を記録して、一番少ないものと置き換え  
参照ビットを用意。定期的にタイマー割り込みをして、アクセス頻度を集計する。集計が終わったら参照ビットをすべて0にする。
#### 問題
頻度の高かった（今となっては必要のなくなった）ページが残り続ける  
局所性と関連が薄い  
### エージング
NFUの改良。  
基本的には一緒だが、アクセス頻度を2進数で左から管理する。  
これにより、たくさんアクセスがあれば頻度が少なく表示できるため、古いページが置き換えられやすくなる。
#### 例
A  0100 --> 4  
B  0000 --> 0 
C  0011 --> 3 
↓ すべてに1を足すと...  
A  1100 --> 10 
B  1000 --> 8 
C  1011 --> 9 
となり、新しいAより参照回数の多いCが置き換えられやすい。
### セカンドチャンス
FIFOの改良  
参照ビットを用意、置き換え発生時に参照ビットが1のページは置き換え候補の一番最後に回す。置き換えたらすべての参照ビットは0になる。あとはFIFOと一緒。  
### クロックアルゴリズム
LRUの近似。  
参照ビットを用意。置き換え時にページを上から順番に見ていって、参照ビットが0であるものと置き換え。  
このとき、見ていったページの参照ビットだけを0にする。  
2回目以降の置き換え時に、見ていくページを前回と同じ場所から再開する。最後まで行ったら最初から。  
#### 考え方
- 参照ビットが１の場合，前回のチェックから，少なくとも1回ページ参照があった．
- 参照ビットが０の場合，前回のチェックから，参照されていない．
### WSClock
クロックアルゴリズム+ワークングセット  
クロックアルゴリズムとほぼ一緒。  
参照ビットと参照時間を入れるスペースを用意。参照時に参照ビットを1、参照時間を現在時刻にする。置き換え時にページを上から順番に見ていって、参照ビットが0であるものの参照時刻を現在時刻を比較。一定以上(あらかじめ手動で決めておく)の差があるものと置き換え。  
## ワーキングセット法
それぞれのプロセスの特性を生かしたページング  
- それぞれのプロセスが良く参照するページをそれぞれ管理する
-大域的では，入力待ちなどで待たされたプロセスは，ページアウトしやすいので，再開時にページフォルトがおきやすい
### ワーキングセット
あるプロセスが，ある時間T内に参照したページの集合(そのとき，参照頻度の高そうなページ)
ページングは，ワーキングセット単位で行う

## スラッシング
高頻度でページフォルトを発生する状況
### 原因
- 主記憶が少ないため，物理ページが不足して
いる
    - 同時実行するプロセス数に対して
    - 各プロセスの動作による（短時間に多くのページを参照するプログラム）
###  改善方法
PFF法やワーキングセット法を用いる

## UNIXでの実例
### ページング
空きページが一定量より少なくなると，ページデーモンを起動し，大域的クロックアルゴリズムで，参照されないページを回収する。pageout, pagedaemon (PID:2)
### スワッピング
ページデーモンのCPU使用時間が一定量を超えたところで，スワップアウトを行い，一回に多数のページを回収する．sched, swapper (PID:0)

# ファイル
## 構造
### レコード
オペレーティングシステムは，ユーザーが指定する大きさや形式に従う．  
OS側でデータ構造を処理する  
- 固定長レコード
- 可変長レコード
- 不定長レコード
MVS等大型計算機のOSに利用  
### ストリーム入出力
特定のファイル構造をもたず，ファイルを汎用的なバイト列として扱う．  
- UNIX, Windows等に使用されている．
- OS側の機能が簡素化される．
- ファイルの柔軟性が高い
- アプリケーション側でデータ構造等を決めなければならないため、アプリケーションの方に負荷がかかる
## 操作
OSは，基本的な読み出しと書き込みをサポート  
ファイルの途中に対する挿入や削除は，OSではサポートしない  
- OSが複雑になるのに見合う効果が無い
- アプリケーション側で十分対応できる
## アクセス方法
ファイルのどの位置を読み出す（書き込む）か？  
### 順アクセス
現在の位置からの相対的な操作を行う。  
Read,Write,Seek(2)など  
- ファイルの先頭から順番にアクセスする．
- 読み出している場所（ファイルポインタ）を移動することができる．
- アクセスの時には，ファイルポインタの場所を指定しなくて良い
### 直接アクセス
どこをアクセスするか直接指定する。  
Read(5),Write(3)など
- アクセスするたびに，その場所を指定する．
- ファイルはブロック単位で場所指定をする．
### 補足  
順アクセスで，直接アクセスのようなことができるが，効率的ではない．  
#### MVS等の大型計算機のOS
順アクセスと直接アクセスの両方がある
#### UNIX, Windows等のOS
順アクセスのみ用意されている  
  
メモリマップドファイルという手法もある
- メモリアクセスと同じ様にアクセスできる（詳しくは記憶管理で）

## ディレクトリについて
ファイルの管理情報
- ファイル名
    - 固定長(MS-DOS, MVS)
    - 可変長(UNIX)
- 型（ファイル属性）
- 物理位置
- ファイルの大きさ
- 時刻（作成・参照など）
### 制約
#### ファイル名の制約
ファイル名で識別しているため,同一のディレクトリ内では一意に決めなければならない．  

#### ディレクトリの階層化
- 各ディレクトリ内で一意であれば良い．ファイル名の制約がゆるくなる
- ユーザーごと，関連するものごとなど整理できる

ディレクトリは木構造。  

## ボリュームとファイル管理
### 記憶媒体
情報を記録する媒体
### ボリューム
 記録媒体の総称
### ボリュームに含まれる情報
- 初期プログラム:システム立ち上げ時に使用するプログラム
- ボリューム管理情報:ボリュームの構成，名前，不良ブロックなど
- ファイル管理情報:ファイルに関する情報
- ファイルデータ
### 使用領域管理
#### リスト方式
線形リスト構造をとる
- 直接アクセスには不向き
- n番目のブロックはn回アクセスが必要
- 空きブロックをリストで保持する
- 空きブロックが必要なときは，先頭から割り当てる
#### 索引方式
どのブロックが使われているかの表を別に持つ
- 索引の領域を用意しなければならない。索引のサイズはどうするか？
- 一定の時間でアクセスできる
#### ビットマップ方式
1ブロックを1ビットで表し，そのビットの値が0と1で空きと使用中を判断する．
- 空きブロックが少ないとき空きブロックの検索に時間がかかる
### ファイルシステムの利用例 
#### リスト管理:MS-DOS (Windows)
• 管理に使うリストは，FATに作られる
• 空き領域管理はFATのエントリに未使用の印をつける
#### 索引管理:UNIX
• 索引テーブルとしてi-nodeがある
• 空き領域管理はビットマップ方式
### ファイルシステムの信頼性
#### 装置の信頼性（ハードディスク）
MTBF:1.4Mhour (約160年)
- HDDが10台あると，システムのMTBF10分の1になる
#### 信頼性の向上
- RAID（Redundant Arrays of Inexpensive Disks）:冗長に記録し，ハードディスクの故障に備える
    - 同じものを2台に保存(RAID1)
    - n台分のデータをn+1台に保存(RAID3,4,5)
    - n台分のデータをn+2台に保存(RAID6)
### ファイルの作成例
1. ファイル名の検索
1. ファイル名の登録
1. ファイルに使用する領域の確保
1. 使用する領域の情報を記録
1. ファイルのデータを記録する
#### (3)までで停止した場合
ディレクトリはあるが，中身なし
#### (4)までで停止した場合
正しい中身の無いファイル

# 入出力装置
## 入出力装置の種類
### ブロック型装置
磁気ディスク他
### キャラクタ型装置
キーボード他
### その他
タイマー他

## 入出力の問題
### 入出力の要求は，CPUの動作と非同期（関係なく）発生する
CPUはプログラムにしたがって動作する
- 入出力の要求を予測するのはほぼ不可能
- 必要なときに対処する仕組み:割り込み
### 入出力装置の動作がCPUより遅い
- CPUを無駄待たせないようにする:割り込み，バッファリング
- CPUに単純作業をさせない:DMA

## データ転送法
### プログラム入出力
- CPUが入出力を行う
- プログラムが簡単
- 高速なデバイスでは不向き
    - CPU利用率がそれほど高くならない
## DMA転送
- 専用のコントローラに入出力を任せる
- CPUの利用率が上がる

## 割り込み
割り込み要求によって，プログラムが一時中断され，割り込みハンドラを実行する．割り込み終了後，中断したところから再開される

### 割り込み要因
#### 外部割込み
- 入出力割込み:正常・異常終了
- システム異常:メモリーエラー・電源異常など
#### 内部割込み
- プログラム割り込み:オーバーフロー，0で割る，特権命令違反，アドレス指定関係
-  システムコール:システムコールを実装するための専用命令実行。システムコール用の命令(Trap命令など)を用い，特権モードに移ること。

### 割り込みの優先度管理
#### 割り込みの優先度
- 緊急性のあるものが割り込み優先度は高い:バスエラー（仮想記憶），電源異常，メモリー異常
- 緊急性の低いものは割り込み優先度は低い:一般の入出力など
#### 割り込み処理の間の割り込み要求
- 優先度の高いものは，要求にすぐこたえる
- 優先度の低いものは，それより高い要求が終了するまで待たせる
- 多重割り込み

### タイマ割り込み
値をセットし，一定の時間間隔で，値を－1し，0になったところで割り込みが発生。定期的な割り込みとして利用  
OS内の時計に利用
- プロセスの実行時間の管理など
- 機器が正常に動作していることを確認する:ウォッチドックタイマ

### ファイルと入出力
#### ファイル
抽象化された入出力を用いてアクセスする．
- 機器の詳細はアプリケーションから見えない．
- Open, close, create, read, write, etc.
#### 他のI/O装置でも同様なアプローチが取れる
装置を抽象化して扱うと，ファイル操作と同じ
操作に統一できる．

### バッファリング
データの受け渡しをするときに，直接渡す
のでなく，中間にバッファを用いて間接的
にデータ交換を行う．AとBが非同期に動くことが可能となる．
- Aは必要なデータをバッファに用意する．
- Bはバッファのデータを受け取る．
#### 利点
- 速度差を吸収できる
- デバイスが扱う物理ブロックサイズと，ＯＳが扱う
論理ブロックサイズをことなるものにできる
    - 機器に依存しないサービスをアプリケーションに提供
できる
    - ブロッキング，デブロッキング

#### キャッシング
キャッシュ:補助記憶装置のデータを一時的に蓄えるバッファ
- 補助記憶装置から一度読み出したデータを主記憶に
保持し，2度目のアクセスは主記憶のデータを渡す．
- 補助記憶装置に書き込むとき，書き込むデータを主記
憶に保持し，あとでディスクに書き出す．

### バッファの構成
- ダブルバッファ
- FIFO
- キャッシュ:有限の主記憶でいかに効率よく扱うか？(入れ替える順番，書き戻しの管理)
### スプーリング
プリンタのように低速デバイスを専用プロセスで管理する．アプリケーションはスプールに要求を書く．