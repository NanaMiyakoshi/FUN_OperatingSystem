# 基礎知識
## 2の補数
ビット反転させて1を足す

# スケジューリング
## 手法
### 到着順
プロセスが実行可能になった順に処理する
- Nonpreemptive scheduling
- アルゴリズムが単純
- プロセスの実行が長時間待たされる可能性がある
- 無限ループがあるとそこでハングアップする
### 処理時間順
処理時間が短いプロセスから割り当てる
- Nonpreemptive scheduling
- 全プロセスの平均応答時間を最小にする
- プロセスの実行時間が予めわかっていないといけないため、統計による予測やユーザーからの見積もりを用いる．
### 残余処理時間順
処理に必要な時間の残りが短いものから
順に実行する
- Preemptive scheduling
### ラウンドロビン
待ち行列の順番で実行され，実行可能状態
になったプロセスは，待ち行列の最後尾に追
加される
- Preemptive scheduling
- すべてのプロセスに均等にCPUを割り当てる
- 実行状態に割り当てられたプロセスは，既定の時間実行した場合，実行可能状態に戻される
- TSS(Time Sharing System)で用いられる
- 優先度がないため，リアルタイム処理には向かない
### 優先度順
優先度の順番で実行する。優先度は，さまざまな決め方がある
- 残余処理時間や，期限なども優先度を決める指標
- IO処理の多いものを高く設定する
    - もともとCPU利用率が低い
    - IO稼働率が上がる
- 優先度が低いプロセスはCPUがなかなか割り当てられない
    - 飢餓状態(starvation)
    - 待ち時間の長さに応じて優先度を変更する:時効化(aging)
### 多重フィードバック
優先度のついた複数の待ち行列
- ある一定以上実行したプロセスの優先度を落とす
- 短い処理のプロセスが優先的に実行される

## スレッド
プログラムの実行単位。プロセスの概念から実行装置（仮想的なCPU）を
独立して考える
### マルチスレッド（multi-thread）
1つのプロセスに対し，複数のスレッドが存在する
- スレッドの切り替えは，プロセスの切り替えより軽い
- スレッド間のメモリ保護機能は（それほど必要では）ない
- スレッドごとにスタックは独立して存在する
- データ領域・プログラム領域は共通

# プロセス間通信
## プロセス間通信
プロセス間での協調動作を行うために情報の交換を行う仕組み
- ソフトウェア割り込み（シグナル）
- 共有メモリ
- パイプ
- メッセージ受け渡し
- 遠隔手続き呼び出し
## ソフトウェア割り込み
プロセスに非同期に発生する事象を捉える仕組み
- ハードウェア割り込みと類似の機能
- プロセスには，それぞれのソフトウェア割り込みに対する割り込みハンドラを定義する
- UNIXやOS/2では，シグナルと呼ばれる機構がある
### 用途
- プロセスの終了
- 非同期の通信など
- プロセスのイニシャライズ
## 共有メモリ
複数のプロセスでアクセスできる領域。それぞれのプロセスでアクセスを管理する

## メッセージ受渡し
OSのサービスを利用してデータの受け渡しを行う
### メッセージパッシングの基本命令
- 送信命令(send)
- 受信命令(receive)

## 通信相手の指定
### 直接通信方式
直接通信先のプロセスを指定する
- ２プロセス間の通信用のリンクは1つだけ設定可
### 間接通信方式
論理的な通信媒体を介して通信する:Channel, Port, Mailbox
- 2プロセス間の通信用リンクを複数作れる
- 1対1，1対多，多対1の通信が可能

## 同期式通信・非同期式通信
### 同期式通信
SendやReceiveを呼び出したプロセスは，メッセージの受け渡しが完了するまで実行が待たされる（ブロックされる）
### 非同期式通信
SendやReceiveを実行したら直ちに制御が戻ってくる。無限のバッファを用いて実現する

## バッファ式通信
送信データをOS内の送信バッファに蓄える。未使用の送信バッファがあるとき，sendを呼び出したプロセスに実行権を渡す。  
未使用の送信バッファに空きがないときは，sendを呼び出したプロセスをバッファが空くまでブロックする。

## メッセージの転送方法
### データをコピーする
受信側のプロセス空間にコピーをする
- ネットワークを介した通信にも適用できる
### 参照を渡す
送信側のデータの書き込まれているアドレスを受信側に渡す
- 受信側の操作が送信側に影響を与える場合がある
- 通信速度がデータ量に依存しない
### アドレスのマッピングを切り替える
ページテーブルのページ登録を切り替える  
Send側のメッセージのあるページをReceive側のページテーブルに登録する。基本的特長などは，参照渡しと同じ

## 固定長・可変長
### 固定長
- 領域割り当てや転送が容易(バッファの管理が容易)
- 使用上の制約が大きい
### 可変長
- 使用上の制約が小さい
- 実装が難しい面がある(バッファの管理が難しい)

### パイプ
ファイルの入出力の基本操作をプロセス間通信に用いたもの
- バイト単位で書き込まれた順に読み出され，一度読み出したものを再度読み出すことができない
- （バイト）ストリーム

## クライアント・サーバ型通信
### クライアント
サーバに対して要求を出す。多数存在する。
### サーバ
クライアントの要求にこたえる。少数存在する。
### サービスの例
Mail, DNS, Web,NFS

## 遠隔手続き呼び出し
### RPC(Remote Procedure Call)
- あるプロセスが別のプロセス要求を出し，その結果を待つ操作
- 手続きの呼び出しと類似
- 手続き呼び出しと類似のインターフェースで，
プロセス間通信を行う
### 手続き呼び出しと異なる点
- タイムアウト機能を準備する

## プロセス間の相互作用
### 競合
複数のプロセスが同じ資源を同時に使用しようとしたときにおきる
- 他のプロセスが資源を使用しないように排除(排他制御)を行う
- 1個のプロセスしか資源の使用が許されない場合は，相互排除(mutual exclusion)という
- プログラムで，排他制御が必要な資源をアクセスする部分をCritical sectionと呼ぶ
### 協調
複数のプロセスが協力し，共通の目的のために実行する形態
- 協調関係にあるプロセスは，互いに他のプロセスの存在を知っている
- 共有資源へのアクセスが適切であるかプロセス間で通知しあい同期を取る
- 条件同期(Conditional synchronization)

## プロセス間の同期のためには？
プロセス間の同期を取るために用いる命令:同期基本命令
- 他のプロセスによって分断されることのない不可分な操作でなければならない

## プロセス間の同期
### 割り込み禁止
- 割り込み禁止命令・割り込み許可命令はそれぞれ1命令
- タイマ割り込みや，入出力割込みが発生しないので，その期間プロセスが切り替わらない
#### 利用
- プロセス切り替え時などのレジスタの回復
#### 欠点
- カーネル内しか使えない
- 短時間しか使えない
- マルチプロセッサシステムでは他のCPUに対しては，意味がない

## ビジーウェイトによる相互排除
クリティカルセクションの前後をlockとunlockという操作ではさみ，排他制御する
### lock時の問題
- lockの動作がCPUでは，複数の命令に分割される．
    - lockの途中で，プロセスが変わる可能性がある
        - クリティカルセクションに複数のプロセスが入ってしまう
        - シングルプロセッサでは，割り込み禁止で対応化
        - マルチプロセッサでは，対応不可

## 排他制御用の命令
CPUには，排他制御用の命令が用意されている
### Test and Set命令
以下の操作を1命令で実行する
- メモリ上のアドレスXの値を読み出し，値をチェック
- 値をチェックした結果をステータスレジスタにセット
- 指定の値をアドレスXメモリ上にセットする
### Compare and Swap命令
以下の操作を1命令で実行する
- メモリ上のアドレスXの値を読み出し，レジスタ値と比較
- チェックした結果をステータスレジスタにセット
- 予めレジスタに指定された値をアドレスXメモリ上にセットする

## ビジーウェイトによる同期(スピンロック)
相互排除は，ループによって絶えずチェックを続ける
- CPUを無駄に使う
- シングルプロセッサの場合は致命的になる可能性がある
- マルチプロセッサに対しては有利な面がある
- 短時間なら，プロセスのsuspend lockより軽い

# メモリ管理
## CPUのアドレッシング
### アドレッシング
アドレス指定の方式
#### 絶対アドレッシング
絶対番地（アドレス）で指定する
- 命令実行が早い
- プログラムを正しいアドレスにロードしないといけない
#### 相対アドレッシング
相対番地（アドレス）で指定する
- 命令実行が遅い(現在のプログラムカウンタと相対アドレスの加算が必要)
- プログラムのロード先は，どのアドレスでも大丈夫

## 単一のプログラムの管理
プログラムを実行する必要があるものに，すべてのメモリ空間を渡す
- 昔のCP/M
- 昔のパソコン
- さまざまなプログラムを実行するとき，その都度，ディスクから読み出さなければならない
- 入出力待ちの時間が全体のパフォーマンスに大きく影響する

## 複数のプログラムの管理
主記憶空間を複数に分割してプログラムを走らせる
### 相対アドレッシング
ディスクに保存されているものがそのまま使う
### 絶対アドレッシング
プログラムを置くアドレスにあわせて，ロード時にプログラム中で指定しているアドレスを変更する

## 論理アドレスとプログラムの再配置
### プログラムの再配置
絶対アドレッシングのとき，予め配置場所が決まる
- コンパイル時
- プログラムをロードしたとき（静的再配置）
- 主記憶の管理上大きな制約:アドレスの変換を行う

## 論理アドレスと物理アドレス
- 物理アドレス（絶対，実アドレス:主記憶上の位置を表す
- 論理アドレス（実効アドレス）:CPUがプログラムやデータを扱う空間
- ベースレジスタの値をかえることで、動的再配置が可能
### セグメント管理
セグメントと呼ばれる複数の領域ごとにベースレジスタを用意する．
- 命令，データ，スタックなどプログラムの内部構造に基づく
- モジュール単位で割り当てる
#### 利点
- 連続領域の要求が（プログラム全体より）小さくてよい
- メモリ保護などにも利用できる
#### 問題点
- ハードウェアのサポートが必要
- 変換にかかる時間のロス:セグメントレジスタの値を変化したときに問題が起きる
- CPU内のパイプラインの乱れ（投機的実行していた部分が無駄になる）

## スワッピング
プロセスが要求するメモリの総量が主記憶のサイズを超えることがある。そのため、主記憶と補助記憶でプログラムの出し入れを行うことをスワッピングという
- 待ち状態のプロセスは，主記憶上に置く必要がない
- 優先度の低いプロセスは補助記憶（HDDなど）に退避する
- 記憶領域が有効に使われる
- 連続した大きな空き領域を作ることができる
- 動的再配置が可能な場合，スワップアウトの時に別の場所における
- 主記憶の有効利用
- 相対アドレッシングのみでプログラムを作らなければならない
### 問題点
スワップイン，スワップアウトに多大の時間がかかる:毎回発生すると，パフォーマンスがとても悪くなる
### 解決法
どのプロセスをスワッピングするか，長期的なスケジュール管理する
- 実行前にスワップインを終了できるようにする
- 必要性の低いプロセスを優先してスワップアウトする
- 基準はプロセスサイズ，優先度，CPUの実行時間など
- 長期スケジューリング

## オーバレイ
ユーザープログラムの中で，同一の記憶領域に複数の実行モジュールを読み込むようにする。一つのプログラムを対象としている。

## 空きメモリ管理
### 固定区画方式
主記憶を固定した区画に分割し，その中でプログラムを実行する

#### 問題点
- 区画内に未使用の無駄なスペースが生じる:内部断片化
- 実行可能プロセス数が区画数によって決まる:実行可能プロセス数と区画サイズがトレードオフ
- 区画以上の大きさのプロセスは生成できない

### 可変区画方式
固定した区画を決めず，必要な量だけ割り当てる。連続した空き領域の中から必要な量を割りあてる。

#### ポイント
- 外部断片化がおきる:連続した空き領域が，空き領域の総量より少なくなる
- 内部断片化はおきない
- メモリ詰め直しが必要
    - 絶対アドレッシングを利用している場合は困難
    - 相対アドレッシングでプログラミングする必要あり
    - 処理が重い

### 可変区画方式における空き領域の管理
空き領域からプロセスにメモリを割り当てる
- 初適合
- 最適適合
- 最悪適合

- 領域の管理方法
    - リスト方式
    - ビットマップ方式

#### 初適合(First-fit)
最初に見つかった十分大きな空き領域に割り当てる
- 空き領域の探索が高速
- 空き領域の結合が容易

#### 最適適合(best-fit)
必要な領域に近い空き領域が常に使われる
- 探索が遅い
- 小さな空き領域が多数発生しやすい
- 空き領域の結合は行いづらい

#### 最悪適合(worst-fit)
最大の空き領域に割り当てる
- 探索は遅い
- 小さな空き領域は発生しづらい
- 領域の利用効率は最悪

#### ビットマップ方式（空き領域の管理）
１ビットで，空き領域か割り当て済み領域か判断する

#### リスト管理（領域の管理）
リスト構造を利用して領域の管理を行う

## 仮想記憶
主記憶と補助記憶装置の両方を用いて，主記憶の大きさにとらわれない仮想的な記憶装置を提供
### 仮想記憶のしくみ
- プログラムは，仮想アドレスを指定する
- プログラムには，主記憶の大きさの制限を見せない
- プログラムには，補助記憶の存在を見せない
    - セグメンテーション
    - ページング
### 仮想記憶の種類
#### 単一仮想記憶
主記憶の大きさの制限を取ることのみ
#### 多重仮想記憶
仮想空間を複数用いる．
- プロセスごと（UNIX）
- ユーザーごと（MVS)

### 仮想記憶の基本的な手法
#### セグメンテーション
プログラムの構造を反映させ，管理上の利点を活用
- 可変長サイズのセグメント単位
- プログラムの構造に基づいたセグメントを単位
##### 分け方
アクセスの種類で分ける
- 命令
- データ
- スタック
- その他
- モジュールごとに分ける
- アドレスの範囲を指定する

#### ページング
仮想記憶をできるだけスムーズに表す
- 固定されたサイズのページ単位
- プログラムの構造と無関係

### ページの分割
アドレスを２つのものに分けて考える
- どのページかをあらわすページ番号
- ページ内のどこか（どのデータか）をあらわすページ内オフセット
#### アドレスからページ番号を求める
アドレス空間を一定の大きさのページに分割し，先頭から数えて何番目かを求める:アドレスをページサイズで割った商
#### アドレスからページ内オフセットを求める
選ばれたページ内で，何番目のデータであるか求める:アドレスをページサイズで割った余り

### ページサイズについて
#### ページサイズを大きくする
- ページ転送時間が少なくなる
- ページ転送回数が少なくなる
- 1回のページ転送量が多くなる
- ページテーブルが小さくなる
- 内部断片化の無駄が多くなる
- 局所参照性が生かせなくなる
- 無駄な部分も同時に読み込む
- 主記憶の利用率の低下
#### ページサイズを小さくする
- ページ転送時間が多くなる
- ページ転送回数が増える
- 1回のページ転送量は少なくなる
- ページテーブルが大きくなる
- 内部断片化の無駄が少なくなる
- 局所参照性が生かすことができる
- 無駄な部分の読み込みが減る
- 主記憶の利用率が高くなる

### アドレス変換の高速化
#### 問題
メモリアクセスのたびにページ参照では遅い
#### 動作特性
メモリアクセスには局所性がある．
#### 解決法
最近変換した変換は，CPU内のバッファに蓄え，それを利用する。メモリ上のページテーブルにはアクセスしない。　　
仮想アドレスで指定したページとバッファ内の仮想ページ番号を比較し，存在する場合は対応する物理ページを返す。  
仮想アドレスで指定したページとバッファ内の仮想ページ番号を比較し，存在しない場合はページテーブルを参照する。

### 補助記憶の領域管理
#### バッキングストア
仮想記憶を実現するために，補助記憶上に確保される，プログラムやデータを保存する領域
- スワップ領域
- ページング領域
- アクセス効率を重視
    - 連続した割り当て
    - ファイルとは別の領域管理など
#### ファイル
領域の効率的利用を重視


## 読み込み
### デマンドページング
ページが参照され，ページフォルトがおきたとき，ページを主記憶に読み込む
### プリページング
ページが参照される前にページを主記憶に読み込む(うまく行けば速い)
## 書き込み
### FIFO
読み込んだ順番が早い順に書き換え
### LRU
最後に読み込んだ時間が一番古いものと置き換え
#### 問題
一回の参照ごとに"すべての"ページの時間の置き換えが必要
### NRU
参照ビットと更新ビットを用意して更新優先度をつける
- 参照ビット:参照されると1,何らかの"置き"換えがあると0に戻る
- 更新ビット:書き込みで1,ベージアウトされると0
  
- クラス0:参照ビット0更新ビット0
- クラス1:参照ビット0更新ビット1
- クラス2:参照ビット1更新ビット0
- クラス3:参照ビット1更新ビット1
### NFU
アクセス頻度を記録して、一番少ないものと置き換え  
参照ビットを用意。定期的にタイマー割り込みをして、アクセス頻度を集計する。集計が終わったら参照ビットをすべて0にする。
#### 問題
頻度の高かった（今となっては必要のなくなった）ページが残り続ける  
局所性と関連が薄い  
### エージング
NFUの改良。  
基本的には一緒だが、アクセス頻度を2進数で左から管理する。  
これにより、たくさんアクセスがあれば頻度が少なく表示できるため、古いページが置き換えられやすくなる。
#### 例
A  0100 --> 4  
B  0000 --> 0 
C  0011 --> 3 
↓ すべてに1を足すと...  
A  1100 --> 10 
B  1000 --> 8 
C  1011 --> 9 
となり、新しいAより参照回数の多いCが置き換えられやすい。
### セカンドチャンス
FIFOの改良  
参照ビットを用意、置き換え発生時に参照ビットが1のページは置き換え候補の一番最後に回す。置き換えたらすべての参照ビットは0になる。あとはFIFOと一緒。  
### クロックアルゴリズム
LRUの近似。  
参照ビットを用意。置き換え時にページを上から順番に見ていって、参照ビットが0であるものと置き換え。  
このとき、見ていったページの参照ビットだけを0にする。  
2回目以降の置き換え時に、見ていくページを前回と同じ場所から再開する。最後まで行ったら最初から。  
#### 考え方
- 参照ビットが１の場合，前回のチェックから，少なくとも1回ページ参照があった．
- 参照ビットが０の場合，前回のチェックから，参照されていない．
### WSClock
クロックアルゴリズム+ワークングセット  
クロックアルゴリズムとほぼ一緒。  
参照ビットと参照時間を入れるスペースを用意。参照時に参照ビットを1、参照時間を現在時刻にする。置き換え時にページを上から順番に見ていって、参照ビットが0であるものの参照時刻を現在時刻を比較。一定以上(あらかじめ手動で決めておく)の差があるものと置き換え。  
## ワーキングセット法
それぞれのプロセスの特性を生かしたページング  
- それぞれのプロセスが良く参照するページをそれぞれ管理する
-大域的では，入力待ちなどで待たされたプロセスは，ページアウトしやすいので，再開時にページフォルトがおきやすい
### ワーキングセット
あるプロセスが，ある時間T内に参照したページの集合(そのとき，参照頻度の高そうなページ)
ページングは，ワーキングセット単位で行う

## スラッシング
高頻度でページフォルトを発生する状況
### 原因
- 主記憶が少ないため，物理ページが不足して
いる
    - 同時実行するプロセス数に対して
    - 各プロセスの動作による（短時間に多くのページを参照するプログラム）
###  改善方法
PFF法やワーキングセット法を用いる

## UNIXでの実例
### ページング
空きページが一定量より少なくなると，ページデーモンを起動し，大域的クロックアルゴリズムで，参照されないページを回収する。pageout, pagedaemon (PID:2)
### スワッピング
ページデーモンのCPU使用時間が一定量を超えたところで，スワップアウトを行い，一回に多数のページを回収する．sched, swapper (PID:0)

# ファイル
## 構造
### レコード
オペレーティングシステムは，ユーザーが指定する大きさや形式に従う．  
OS側でデータ構造を処理する  
- 固定長レコード
- 可変長レコード
- 不定長レコード
MVS等大型計算機のOSに利用  
### ストリーム入出力
特定のファイル構造をもたず，ファイルを汎用的なバイト列として扱う．  
- UNIX, Windows等に使用されている．
- OS側の機能が簡素化される．
- ファイルの柔軟性が高い
- アプリケーション側でデータ構造等を決めなければならないため、アプリケーションの方に負荷がかかる
## 操作
OSは，基本的な読み出しと書き込みをサポート  
ファイルの途中に対する挿入や削除は，OSではサポートしない  
- OSが複雑になるのに見合う効果が無い
- アプリケーション側で十分対応できる
## アクセス方法
ファイルのどの位置を読み出す（書き込む）か？  
### 順アクセス
現在の位置からの相対的な操作を行う。  
Read,Write,Seek(2)など  
- ファイルの先頭から順番にアクセスする．
- 読み出している場所（ファイルポインタ）を移動することができる．
- アクセスの時には，ファイルポインタの場所を指定しなくて良い
### 直接アクセス
どこをアクセスするか直接指定する。  
Read(5),Write(3)など
- アクセスするたびに，その場所を指定する．
- ファイルはブロック単位で場所指定をする．
### 補足  
順アクセスで，直接アクセスのようなことができるが，効率的ではない．  
#### MVS等の大型計算機のOS
順アクセスと直接アクセスの両方がある
#### UNIX, Windows等のOS
順アクセスのみ用意されている  
  
メモリマップドファイルという手法もある
- メモリアクセスと同じ様にアクセスできる（詳しくは記憶管理で）

## ディレクトリについて
ファイルの管理情報
- ファイル名
    - 固定長(MS-DOS, MVS)
    - 可変長(UNIX)
- 型（ファイル属性）
- 物理位置
- ファイルの大きさ
- 時刻（作成・参照など）
### 制約
#### ファイル名の制約
ファイル名で識別しているため,同一のディレクトリ内では一意に決めなければならない．  

#### ディレクトリの階層化
- 各ディレクトリ内で一意であれば良い．ファイル名の制約がゆるくなる
- ユーザーごと，関連するものごとなど整理できる

ディレクトリは木構造。  

## ボリュームとファイル管理
### 記憶媒体
情報を記録する媒体
### ボリューム
 記録媒体の総称
### ボリュームに含まれる情報
- 初期プログラム:システム立ち上げ時に使用するプログラム
- ボリューム管理情報:ボリュームの構成，名前，不良ブロックなど
- ファイル管理情報:ファイルに関する情報
- ファイルデータ
### 使用領域管理
#### リスト方式
線形リスト構造をとる
- 直接アクセスには不向き
- n番目のブロックはn回アクセスが必要
- 空きブロックをリストで保持する
- 空きブロックが必要なときは，先頭から割り当てる
#### 索引方式
どのブロックが使われているかの表を別に持つ
- 索引の領域を用意しなければならない。索引のサイズはどうするか？
- 一定の時間でアクセスできる
#### ビットマップ方式
1ブロックを1ビットで表し，そのビットの値が0と1で空きと使用中を判断する．
- 空きブロックが少ないとき空きブロックの検索に時間がかかる
### ファイルシステムの利用例 
#### リスト管理:MS-DOS (Windows)
• 管理に使うリストは，FATに作られる
• 空き領域管理はFATのエントリに未使用の印をつける
#### 索引管理:UNIX
• 索引テーブルとしてi-nodeがある
• 空き領域管理はビットマップ方式
### ファイルシステムの信頼性
#### 装置の信頼性（ハードディスク）
MTBF:1.4Mhour (約160年)
- HDDが10台あると，システムのMTBF10分の1になる
#### 信頼性の向上
- RAID（Redundant Arrays of Inexpensive Disks）:冗長に記録し，ハードディスクの故障に備える
    - 同じものを2台に保存(RAID1)
    - n台分のデータをn+1台に保存(RAID3,4,5)
    - n台分のデータをn+2台に保存(RAID6)
### ファイルの作成例
1. ファイル名の検索
1. ファイル名の登録
1. ファイルに使用する領域の確保
1. 使用する領域の情報を記録
1. ファイルのデータを記録する
#### (3)までで停止した場合
ディレクトリはあるが，中身なし
#### (4)までで停止した場合
正しい中身の無いファイル

# 入出力装置
## 入出力装置の種類
### ブロック型装置
磁気ディスク他
### キャラクタ型装置
キーボード他
### その他
タイマー他

## 入出力の問題
### 入出力の要求は，CPUの動作と非同期（関係なく）発生する
CPUはプログラムにしたがって動作する
- 入出力の要求を予測するのはほぼ不可能
- 必要なときに対処する仕組み:割り込み
### 入出力装置の動作がCPUより遅い
- CPUを無駄待たせないようにする:割り込み，バッファリング
- CPUに単純作業をさせない:DMA

## データ転送法
### プログラム入出力
- CPUが入出力を行う
- プログラムが簡単
- 高速なデバイスでは不向き
    - CPU利用率がそれほど高くならない
## DMA転送
- 専用のコントローラに入出力を任せる
- CPUの利用率が上がる

## 割り込み
割り込み要求によって，プログラムが一時中断され，割り込みハンドラを実行する．割り込み終了後，中断したところから再開される

### 割り込み要因
#### 外部割込み
- 入出力割込み:正常・異常終了
- システム異常:メモリーエラー・電源異常など
#### 内部割込み
- プログラム割り込み:オーバーフロー，0で割る，特権命令違反，アドレス指定関係
-  システムコール:システムコールを実装するための専用命令実行。システムコール用の命令(Trap命令など)を用い，特権モードに移ること。

### 割り込みの優先度管理
#### 割り込みの優先度
- 緊急性のあるものが割り込み優先度は高い:バスエラー（仮想記憶），電源異常，メモリー異常
- 緊急性の低いものは割り込み優先度は低い:一般の入出力など
#### 割り込み処理の間の割り込み要求
- 優先度の高いものは，要求にすぐこたえる
- 優先度の低いものは，それより高い要求が終了するまで待たせる
- 多重割り込み

### タイマ割り込み
値をセットし，一定の時間間隔で，値を－1し，0になったところで割り込みが発生。定期的な割り込みとして利用  
OS内の時計に利用
- プロセスの実行時間の管理など
- 機器が正常に動作していることを確認する:ウォッチドックタイマ

### ファイルと入出力
#### ファイル
抽象化された入出力を用いてアクセスする．
- 機器の詳細はアプリケーションから見えない．
- Open, close, create, read, write, etc.
#### 他のI/O装置でも同様なアプローチが取れる
装置を抽象化して扱うと，ファイル操作と同じ
操作に統一できる．

### バッファリング
データの受け渡しをするときに，直接渡す
のでなく，中間にバッファを用いて間接的
にデータ交換を行う．AとBが非同期に動くことが可能となる．
- Aは必要なデータをバッファに用意する．
- Bはバッファのデータを受け取る．
#### 利点
- 速度差を吸収できる
- デバイスが扱う物理ブロックサイズと，ＯＳが扱う
論理ブロックサイズをことなるものにできる
    - 機器に依存しないサービスをアプリケーションに提供
できる
    - ブロッキング，デブロッキング

#### キャッシング
キャッシュ:補助記憶装置のデータを一時的に蓄えるバッファ
- 補助記憶装置から一度読み出したデータを主記憶に
保持し，2度目のアクセスは主記憶のデータを渡す．
- 補助記憶装置に書き込むとき，書き込むデータを主記
憶に保持し，あとでディスクに書き出す．

### バッファの構成
- ダブルバッファ
- FIFO
- キャッシュ:有限の主記憶でいかに効率よく扱うか？(入れ替える順番，書き戻しの管理)
### スプーリング
プリンタのように低速デバイスを専用プロセスで管理する．アプリケーションはスプールに要求を書く．

# デッドロック
## デッドロック発生の必要条件
### 相互排他条件
資源がひとつのプロセスに割り付けているとき，他のプロセスが利用できない
### 確保待ち条件
ある資源をすでに持っているプロセスが，さらに他の資源を要求して，解放されるのを待っている．
### 横取り不可能条件
プロセスに割り当てられた資源は横取り不可能である
### 循環待ち条件
2つかそれ以上のプロセスが資源が解放されるのを待っているとき，資源待ちが循環している

## デッドロックからの回復
### 強制終了
資源をつかんでいるプロセスを強制終了し，資源を解放する
### ロールバック
過去のある時点まで実行状態を戻し，再実行する  
資源を確保する前の状態に戻すことで，循環待ちを解消する

## デッドロックに対する対応
### 対応しない
起こってから考える
### 起こらないように資源管理する
最低1つのプロセスが終了できるだけの資源量を確保するように資源割り当てを行う．
- 銀行家のアルゴリズム:資源が不足して割り当て困難になる状況を作らない
### 起こる条件の回避
- 相互排他が起きないようにする
- 確保待ちが起きないようにする
#### 2相ロック：全資源をロックし，必要な資源の状態を
確認する．利用できる場合は，必要な資源のみロックし，全体ロックを解除する．