# メモリ管理
## 読み込み
### デマンドページング
ページが参照され，ページフォルトがおきたとき，ページを主記憶に読み込む
### プリページング
ページが参照される前にページを主記憶に読み込む(うまく行けば速い)
## 書き込み
### FIFO
読み込んだ順番が早い順に書き換え
### LRU
最後に読み込んだ時間が一番古いものと置き換え
#### 問題
一回の参照ごとに"すべての"ページの時間の置き換えが必要
### NRU
参照ビットと更新ビットを用意して更新優先度をつける
- 参照ビット:参照されると1,何らかの"置き"換えがあると0に戻る
- 更新ビット:書き込みで1,ベージアウトされると0
  
- クラス0:参照ビット0更新ビット0
- クラス1:参照ビット0更新ビット1
- クラス2:参照ビット1更新ビット0
- クラス3:参照ビット1更新ビット1
### NFU
アクセス頻度を記録して、一番少ないものと置き換え  
参照ビットを用意。定期的にタイマー割り込みをして、アクセス頻度を集計する。集計が終わったら参照ビットをすべて0にする。
#### 問題
頻度の高かった（今となっては必要のなくなった）ページが残り続ける  
局所性と関連が薄い  
### エージング
NFUの改良。  
基本的には一緒だが、アクセス頻度を2進数で左から管理する。  
これにより、たくさんアクセスがあれば頻度が少なく表示できるため、古いページが置き換えられやすくなる。
#### 例
A  0100  
B  0000  
C  0011  
↓ すべてに1を足すと...  
A  1100  
B  1000  
C  1011  
となり、新しいAより参照回数の多いCが置き換えられやすい。
### セカンドチャンス
FIFOの改良  
参照ビットを用意、置き換え発生時に参照ビットが1のページは置き換え候補の一番最後に回す。置き換えたらすべての参照ビットは0になる。あとはFIFOと一緒。  
### クロックアルゴリズム
LRUの近似。  
参照ビットを用意。置き換え時にページを上から順番に見ていって、参照ビットが0であるものと置き換え。  
このとき、見ていったページの参照ビットだけを0にする。  
2回目以降の置き換え時に、見ていくページを前回と同じ場所から再開する。最後まで行ったら最初から。  
#### 考え方
- 参照ビットが１の場合，前回のチェックから，少なくとも1回ページ参照があった．
- 参照ビットが０の場合，前回のチェックから，参照されていない．
### WSClock
クロックアルゴリズム+ワークングセット  
クロックアルゴリズムとほぼ一緒。  
参照ビットと参照時間を入れるスペースを用意。参照時に参照ビットを1、参照時間を現在時刻にする。置き換え時にページを上から順番に見ていって、参照ビットが0であるものの参照時刻を現在時刻を比較。一定以上(あらかじめ手動で決めておく)の差があるものと置き換え。  
## ワーキングセット法
それぞれのプロセスの特性を生かしたページング  
- それぞれのプロセスが良く参照するページをそれぞれ管理する
-大域的では，入力待ちなどで待たされたプロセスは，ページアウトしやすいので，再開時にページフォルトがおきやすい
### ワーキングセット
あるプロセスが，ある時間T内に参照したページの集合(そのとき，参照頻度の高そうなページ)
ページングは，ワーキングセット単位で行う

## スラッシング
高頻度でページフォルトを発生する状況
### 原因
- 主記憶が少ないため，物理ページが不足して
いる
    - 同時実行するプロセス数に対して
    - 各プロセスの動作による（短時間に多くのページを参照するプログラム）
###  改善方法
PFF法やワーキングセット法を用いる

## UNIXでの実例
### ページング
空きページが一定量より少なくなると，ページデーモンを起動し，大域的クロックアルゴリズムで，参照されないページを回収する。pageout, pagedaemon (PID:2)
### スワッピング
ページデーモンのCPU使用時間が一定量を超えたところで，スワップアウトを行い，一回に多数のページを回収する．sched, swapper (PID:0)