# 基礎知識
## 2の補数
ビット反転させて1を足す

# メモリ管理
## 読み込み
### デマンドページング
ページが参照され，ページフォルトがおきたとき，ページを主記憶に読み込む
### プリページング
ページが参照される前にページを主記憶に読み込む(うまく行けば速い)
## 書き込み
### FIFO
読み込んだ順番が早い順に書き換え
### LRU
最後に読み込んだ時間が一番古いものと置き換え
#### 問題
一回の参照ごとに"すべての"ページの時間の置き換えが必要
### NRU
参照ビットと更新ビットを用意して更新優先度をつける
- 参照ビット:参照されると1,何らかの"置き"換えがあると0に戻る
- 更新ビット:書き込みで1,ベージアウトされると0
  
- クラス0:参照ビット0更新ビット0
- クラス1:参照ビット0更新ビット1
- クラス2:参照ビット1更新ビット0
- クラス3:参照ビット1更新ビット1
### NFU
アクセス頻度を記録して、一番少ないものと置き換え  
参照ビットを用意。定期的にタイマー割り込みをして、アクセス頻度を集計する。集計が終わったら参照ビットをすべて0にする。
#### 問題
頻度の高かった（今となっては必要のなくなった）ページが残り続ける  
局所性と関連が薄い  
### エージング
NFUの改良。  
基本的には一緒だが、アクセス頻度を2進数で左から管理する。  
これにより、たくさんアクセスがあれば頻度が少なく表示できるため、古いページが置き換えられやすくなる。
#### 例
A  0100  
B  0000  
C  0011  
↓ すべてに1を足すと...  
A  1100  
B  1000  
C  1011  
となり、新しいAより参照回数の多いCが置き換えられやすい。
### セカンドチャンス
FIFOの改良  
参照ビットを用意、置き換え発生時に参照ビットが1のページは置き換え候補の一番最後に回す。置き換えたらすべての参照ビットは0になる。あとはFIFOと一緒。  
### クロックアルゴリズム
LRUの近似。  
参照ビットを用意。置き換え時にページを上から順番に見ていって、参照ビットが0であるものと置き換え。  
このとき、見ていったページの参照ビットだけを0にする。  
2回目以降の置き換え時に、見ていくページを前回と同じ場所から再開する。最後まで行ったら最初から。  
#### 考え方
- 参照ビットが１の場合，前回のチェックから，少なくとも1回ページ参照があった．
- 参照ビットが０の場合，前回のチェックから，参照されていない．
### WSClock
クロックアルゴリズム+ワークングセット  
クロックアルゴリズムとほぼ一緒。  
参照ビットと参照時間を入れるスペースを用意。参照時に参照ビットを1、参照時間を現在時刻にする。置き換え時にページを上から順番に見ていって、参照ビットが0であるものの参照時刻を現在時刻を比較。一定以上(あらかじめ手動で決めておく)の差があるものと置き換え。  
## ワーキングセット法
それぞれのプロセスの特性を生かしたページング  
- それぞれのプロセスが良く参照するページをそれぞれ管理する
-大域的では，入力待ちなどで待たされたプロセスは，ページアウトしやすいので，再開時にページフォルトがおきやすい
### ワーキングセット
あるプロセスが，ある時間T内に参照したページの集合(そのとき，参照頻度の高そうなページ)
ページングは，ワーキングセット単位で行う

## スラッシング
高頻度でページフォルトを発生する状況
### 原因
- 主記憶が少ないため，物理ページが不足して
いる
    - 同時実行するプロセス数に対して
    - 各プロセスの動作による（短時間に多くのページを参照するプログラム）
###  改善方法
PFF法やワーキングセット法を用いる

## UNIXでの実例
### ページング
空きページが一定量より少なくなると，ページデーモンを起動し，大域的クロックアルゴリズムで，参照されないページを回収する。pageout, pagedaemon (PID:2)
### スワッピング
ページデーモンのCPU使用時間が一定量を超えたところで，スワップアウトを行い，一回に多数のページを回収する．sched, swapper (PID:0)

# ファイル
## 構造
### レコード
オペレーティングシステムは，ユーザーが指定する大きさや形式に従う．  
OS側でデータ構造を処理する  
- 固定長レコード
- 可変長レコード
- 不定長レコード
MVS等大型計算機のOSに利用  
### ストリーム入出力
特定のファイル構造をもたず，ファイルを汎用的なバイト列として扱う．  
- UNIX, Windows等に使用されている．
- OS側の機能が簡素化される．
- ファイルの柔軟性が高い
- アプリケーション側でデータ構造等を決めなければならないため、アプリケーションの方に負荷がかかる
## 操作
OSは，基本的な読み出しと書き込みをサポート  
ファイルの途中に対する挿入や削除は，OSではサポートしない  
- OSが複雑になるのに見合う効果が無い
- アプリケーション側で十分対応できる
## アクセス方法
ファイルのどの位置を読み出す（書き込む）か？  
### 順アクセス
現在の位置からの相対的な操作を行う。  
Read,Write,Seek(2)など  
- ファイルの先頭から順番にアクセスする．
- 読み出している場所（ファイルポインタ）を移動することができる．
- アクセスの時には，ファイルポインタの場所を指定しなくて良い
### 直接アクセス
どこをアクセスするか直接指定する。  
Read(5),Write(3)など
- アクセスするたびに，その場所を指定する．
- ファイルはブロック単位で場所指定をする．
### 補足  
順アクセスで，直接アクセスのようなことができるが，効率的ではない．  
#### MVS等の大型計算機のOS
順アクセスと直接アクセスの両方がある
#### UNIX, Windows等のOS
順アクセスのみ用意されている  
  
メモリマップドファイルという手法もある
- メモリアクセスと同じ様にアクセスできる（詳しくは記憶管理で）

## ディレクトリについて
ファイルの管理情報
- ファイル名
    - 固定長(MS-DOS, MVS)
    - 可変長(UNIX)
- 型（ファイル属性）
- 物理位置
- ファイルの大きさ
- 時刻（作成・参照など）
### 制約
#### ファイル名の制約
ファイル名で識別しているため,同一のディレクトリ内では一意に決めなければならない．  

#### ディレクトリの階層化
- 各ディレクトリ内で一意であれば良い．ファイル名の制約がゆるくなる
- ユーザーごと，関連するものごとなど整理できる

ディレクトリは木構造。  